#!/bin/bash
set -euo pipefail

CONTAINER_NAME="pki-authority"
CPU_TYPE="untrusted"
if [[ -c "/dev/tdx_guest" ]] ; then
    CPU_TYPE="tdx";
elif [[ -c "/dev/sev-guest" ]]; then
    CPU_TYPE="sev-snp";
fi

export CPU_TYPE="${CPU_TYPE}"

# Create LXC container if it doesn't exist
create_container() {
    if lxc-info -n "${CONTAINER_NAME}" &>/dev/null; then
        echo "Container '${CONTAINER_NAME}' already exists."
    else
        echo "Container '${CONTAINER_NAME}' not found. Creating..."
        lxc-create -n "${CONTAINER_NAME}" -t oci -- --url docker-archive:/etc/super/containers/pki-authority.tar
        echo "Container '${CONTAINER_NAME}' created."
    fi
}

# Set own challenge type in LXC container configuration
set_own_challenge() {
    local src_yaml="/root/containers/lxc-template.yaml"
    local dst_yaml="/var/lib/lxc/${CONTAINER_NAME}/rootfs/app/conf/lxc.yaml"
    
    if [[ -f "${src_yaml}" ]]; then
        if command -v yq-go >/dev/null 2>&1; then
            yq-go e '.pki.ownChallenge.type = strenv(CPU_TYPE)' "${src_yaml}" > "${dst_yaml}"
            echo "Patched ${dst_yaml} with type: ${CPU_TYPE} using yq."
        else
            echo "Error: yq-go is not installed. Please install yq-go for YAML editing."
            exit 1
        fi
    else
        echo "Error: ${src_yaml} not found."
        exit 1
    fi
}

# Copy trusted environment variables to container
set_subbroot_env() {
    # --- Trusted subroot env handling ---
    local trusted_vars=(
        AS__pki__baseDomain
        AS__pki__ownDomain
        AS__pki__certParams__ocspUrl
        AS__pki__mode__attestationServiceSource__baseUrl
        AS__pki__mode__attestationServiceSource__caBundle
    )

    local src_subroot_env="/sp/subroot.env"
    local dst_subroot_env="/var/lib/lxc/${CONTAINER_NAME}/rootfs/app/subroot.env"

    # If source exists, (re)create destination with only trusted variables
    if [[ -f "${src_subroot_env}" ]]; then
        # Remove destination first to ensure a clean recreate
        rm -f "${dst_subroot_env}"

        # Header explaining autogenerated file
        echo "# Autogenerated from ${src_subroot_env}. Contains only trusted variables." > "${dst_subroot_env}"

        for var in "${trusted_vars[@]}"; do
            # capture first matching line in form VAR="value"
            local line
            line="$(grep -m1 -E "^${var}=\".*\"" "${src_subroot_env}" 2>/dev/null || true)"
            if [[ -n "${line}" ]]; then
                echo "${line}" >> "${dst_subroot_env}"
            fi
        done

        chmod 0644 "${dst_subroot_env}" || true
        echo "Created ${dst_subroot_env} with trusted variables."
    else
        echo "Info: ${src_subroot_env} not found; skipping creation of ${dst_subroot_env}"
    fi
}

# Patch LXC container configuration
patch_lxc_config() {
    local config_file="/var/lib/lxc/${CONTAINER_NAME}/config"
    local config_bak="${config_file}.bak"

    # Always restore config from backup if backup exists
    if [[ -f "${config_bak}" ]]; then
        cp "${config_bak}" "${config_file}"
    else
        # Create backup before first patch
        if [[ -f "${config_file}" ]]; then
            cp "${config_file}" "${config_bak}"
        fi
    fi

    # This MAC address is used to get a static IP address from DHCP, see /etc/lxc/dnsmasq.conf
    echo "lxc.net.0.hwaddr = 4e:fc:0a:d5:2d:ff" >> "${config_file}"

    if [[ "${CPU_TYPE}" = "sev-snp" ]]; then
        local dev_id
        dev_id="$(stat -c '%t:%T' /dev/sev-guest | awk -F: '{printf "%d:%d\n", "0x"$1, "0x"$2}')"
        echo "lxc.cgroup2.devices.allow = c ${dev_id} rwm" >> "${config_file}"
        echo "lxc.mount.entry = /dev/sev-guest dev/sev-guest none bind,optional,create=file" >> "${config_file}"
    elif [[ "${CPU_TYPE}" = "tdx" ]]; then
        local dev_id
        dev_id="$(stat -c '%t:%T' /dev/tdx_guest | awk -F: '{printf "%d:%d\n", "0x"$1, "0x"$2}')"
        echo "lxc.cgroup2.devices.allow = c ${dev_id} rwm" >> "${config_file}"
        echo "lxc.mount.entry = /dev/tdx_guest dev/tdx_guest none bind,optional,create=file" >> "${config_file}"
        if [[ -f "/etc/tdx-attest.conf" ]]; then
            echo "lxc.mount.entry = /etc/tdx-attest.conf etc/tdx-attest.conf none bind,ro,create=file" >> "${config_file}"
        fi
    fi
}

# Update PCCS URL and setup iptables NAT rules for LXC container access to host service
update_pccs_url_and_setup_iptables() {
    local bridge_name="lxcbr0"
    local service_port="8081"
    local qcnl_conf="/var/lib/lxc/${CONTAINER_NAME}/rootfs/etc/sgx_default_qcnl.conf"
    local qcnl_conf_bak="${qcnl_conf}.bak"
    
    # Get host IP address on the LXC bridge
    local host_ip
    host_ip=$(ip -4 addr show "${bridge_name}" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n1)
    
    if [[ -z "${host_ip}" ]]; then
        echo "Error: Could not determine IP address for bridge ${bridge_name}"
        exit 1
    fi
    
    #local network=$(echo "${host_ip}" | awk -F. '{print $1"."$2"."$3".0/24"}')

    # Enable route_localnet for the bridge to allow routing to localhost
    if [[ $(sysctl -n net.ipv4.conf.${bridge_name}.route_localnet 2>/dev/null) != "1" ]]; then
        sysctl -w net.ipv4.conf.${bridge_name}.route_localnet=1
        echo "Enabled route_localnet for ${bridge_name}"
    else
        echo "route_localnet already enabled for ${bridge_name}"
    fi
    
    # Add DNAT rule to redirect traffic from LXC bridge to localhost (if not already present)
    if ! iptables -t nat -C PREROUTING -p tcp -d "${host_ip}" --dport "${service_port}" -j DNAT --to-destination 127.0.0.1:"${service_port}" 2>/dev/null; then
        iptables -t nat -A PREROUTING -p tcp -d "${host_ip}" --dport "${service_port}" -j DNAT --to-destination 127.0.0.1:"${service_port}"
        echo "iptables DNAT rule added: ${host_ip}:${service_port} -> 127.0.0.1:${service_port}"
    else
        echo "iptables DNAT rule already exists for ${host_ip}:${service_port}"
    fi
    
    # Add MASQUERADE rule for the network (if not already present)
    #if ! iptables -t nat -C POSTROUTING -s "${network}" -j MASQUERADE 2>/dev/null; then
    #    iptables -t nat -A POSTROUTING -s "${network}" -j MASQUERADE
    #    echo "iptables MASQUERADE rule added for network ${network}"
    #else
    #    echo "iptables MASQUERADE rule already exists for network ${network}"
    #fi
    
    # Update PCCS URL in QCNL configuration
    local pccs_url="https://${host_ip}:${service_port}/sgx/certification/v4/"
    if [[ -f "${qcnl_conf}" ]]; then
        # Create backup if it doesn't exist
        if [[ ! -f "${qcnl_conf_bak}" ]]; then
            cp "${qcnl_conf}" "${qcnl_conf_bak}"
            # Update pccs_url in the JSON configuration file
            sed -i "s|\"pccs_url\": \".*\"|\"pccs_url\": \"${pccs_url}\"|g" "${qcnl_conf}"
            echo "Updated PCCS URL in ${qcnl_conf} to ${pccs_url}"
        else
            echo "Backup ${qcnl_conf_bak} already exists, skipping PCCS URL update"
        fi
    else
        echo "Error: ${qcnl_conf} not found"
        exit 1
    fi
}

create_container
set_own_challenge
set_subbroot_env
patch_lxc_config
update_pccs_url_and_setup_iptables
